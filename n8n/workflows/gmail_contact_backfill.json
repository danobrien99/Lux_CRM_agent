{
  "name": "gmail_contact_backfill",
  "nodes": [
    {
      "parameters": {},
      "id": "manual",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        220,
        260
      ]
    },
    {
      "parameters": {
        "authentication": "oAuth2",
        "resource": "sheet",
        "operation": "read",
        "sheetId": "1_126A0A6-yX6n5sQYmsH_Jbk900yzjDaUy4jyX_aWT0",
        "range": "Contacts!A:Z",
        "dataStartRow": 2,
        "keyRow": 1,
        "options": {
          "continue": true,
          "valueRenderMode": "UNFORMATTED_VALUE"
        }
      },
      "id": "read_contacts_sheet",
      "name": "Read Contacts Sheet",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 2,
      "position": [
        500,
        260
      ]
    },
    {
      "parameters": {
        "jsCode": "const YEARS_BACK = 2; // How many years of history to backfill\nconst WINDOW_SIZE_MONTHS = 12; // Query one window at a time\nconst MAX_CONTACTS_PER_RUN = 0; // 0 = all contacts from sheet\nconst BACKFILL_CONTACT_MODE = 'skip_previously_processed'; // 'skip_previously_processed' or 'reprocess_all'\nconst BACKFILL_API_BASE_URL = 'http://api:8000';\n\nconst normalizedMode = String(BACKFILL_CONTACT_MODE || '').trim().toLowerCase();\nconst contactMode = normalizedMode === 'reprocess_all' ? 'reprocess_all' : 'skip_previously_processed';\n\nconst readField = (source, keys) => {\n  for (const key of keys) {\n    const value = source[key];\n    if (value !== undefined && value !== null && String(value).trim() !== '') return value;\n  }\n  return '';\n};\n\nconst toIsoDate = (value) => {\n  const year = value.getUTCFullYear();\n  const month = String(value.getUTCMonth() + 1).padStart(2, '0');\n  const day = String(value.getUTCDate()).padStart(2, '0');\n  return `${year}/${month}/${day}`;\n};\n\nconst unique = new Map();\nfor (const item of items) {\n  const source = item.json ?? {};\n  const email = String(readField(source, ['primary_email', 'primaryEmail', 'Primary Email', 'Email']))\n    .trim()\n    .toLowerCase();\n  if (!email || unique.has(email)) continue;\n\n  const contactId = String(readField(source, ['contact_id', 'contactId', 'Contact ID', 'ContactId'])).trim();\n  unique.set(email, { contact_id: contactId || null, primary_email: email });\n}\n\nconst contacts = Array.from(unique.values());\nif (contacts.length === 0) {\n  throw new Error('No contact emails found in sheet. Expected primary_email (or Email) column.');\n}\n\nconst limitedContacts = MAX_CONTACTS_PER_RUN > 0 ? contacts.slice(0, MAX_CONTACTS_PER_RUN) : contacts;\n\nlet processedContactIds = new Set();\nlet processedPrimaryEmails = new Set();\nif (contactMode === 'skip_previously_processed') {\n  const apiBaseUrl = String(BACKFILL_API_BASE_URL || 'http://api:8000').replace(/\\/+$/, '');\n  const statusUrl = `${apiBaseUrl}/v1/admin/backfill_contact_status`;\n  const headers = {};\n  if ($env.N8N_WEBHOOK_SECRET) {\n    headers['X-Webhook-Secret'] = $env.N8N_WEBHOOK_SECRET;\n  }\n\n  const response = await fetch(statusUrl, { method: 'GET', headers });\n  if (!response.ok) {\n    const errorBody = await response.text();\n    throw new Error(`Failed fetching processed contacts (${response.status}): ${errorBody.slice(0, 240)}`);\n  }\n\n  const payload = await response.json();\n  const ids = Array.isArray(payload?.processed_contact_ids) ? payload.processed_contact_ids : [];\n  const emails = Array.isArray(payload?.processed_primary_emails) ? payload.processed_primary_emails : [];\n\n  processedContactIds = new Set(ids.map((value) => String(value).trim()).filter(Boolean));\n  processedPrimaryEmails = new Set(emails.map((value) => String(value).trim().toLowerCase()).filter(Boolean));\n}\n\nconst selectedContacts = limitedContacts.filter((contact) => {\n  if (contactMode !== 'skip_previously_processed') {\n    return true;\n  }\n  const contactId = String(contact.contact_id || '').trim();\n  if (contactId && processedContactIds.has(contactId)) {\n    return false;\n  }\n  return !processedPrimaryEmails.has(contact.primary_email);\n});\n\nif (selectedContacts.length === 0) {\n  return [];\n}\n\nconst now = new Date();\nconst backfillStart = new Date(Date.UTC(now.getUTCFullYear() - YEARS_BACK, now.getUTCMonth(), now.getUTCDate()));\nconst queue = [];\n\nfor (let index = 0; index < selectedContacts.length; index += 1) {\n  const contact = selectedContacts[index];\n  let cursorEnd = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + 1));\n\n  while (cursorEnd > backfillStart) {\n    let cursorStart = new Date(cursorEnd);\n    cursorStart.setUTCMonth(cursorStart.getUTCMonth() - WINDOW_SIZE_MONTHS);\n    if (cursorStart < backfillStart) {\n      cursorStart = new Date(backfillStart);\n    }\n\n    const after = toIsoDate(cursorStart);\n    const before = toIsoDate(cursorEnd);\n    const query = `(from:${contact.primary_email} OR to:${contact.primary_email} OR cc:${contact.primary_email}) after:${after} before:${before}`;\n\n    queue.push({\n      json: {\n        ...contact,\n        query,\n        window_after: after,\n        window_before: before,\n        contact_index: index + 1,\n        contact_total: selectedContacts.length,\n        backfill_contact_mode: contactMode,\n      },\n    });\n\n    cursorEnd = cursorStart;\n  }\n}\n\nif (queue.length === 0) {\n  throw new Error('Backfill queue is empty. Check YEARS_BACK and contact sheet values.');\n}\n\nreturn queue;"
      },
      "id": "build_contact_queue",
      "name": "Build Contact Queue",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        760,
        260
      ]
    },
    {
      "parameters": {
        "authentication": "oAuth2",
        "resource": "message",
        "operation": "getAll",
        "returnAll": true,
        "simple": true,
        "filters": {
          "q": "={{$json.query}}",
          "readStatus": "both"
        },
        "options": {}
      },
      "id": "gmail_get_many",
      "name": "Gmail Get Many",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.2,
      "position": [
        1020,
        260
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const normalizeMode = (value) => {\n  const raw = String(value ?? '').trim().toLowerCase();\n  return raw === 'reprocess_all' ? 'reprocess_all' : 'skip_previously_processed';\n};\n\nconst readMeta = (payload) => {\n  const source = payload && typeof payload === 'object' ? payload : {};\n  const metadata = source.metadata && typeof source.metadata === 'object' ? source.metadata : {};\n  return {\n    contact_id: source.contact_id ?? metadata.contact_id ?? null,\n    primary_email: source.primary_email ?? metadata.primary_email ?? null,\n    window_after: source.window_after ?? metadata.window_after ?? null,\n    window_before: source.window_before ?? metadata.window_before ?? null,\n    query: source.query ?? metadata.query ?? null,\n  };\n};\n\nconst seen = new Set();\nconst deduped = [];\n\nfor (const item of items) {\n  const msg = item.json ?? {};\n  const key = String(\n    msg.id ||\n    msg.messageId ||\n    msg['Message-ID'] ||\n    `${msg.threadId || ''}:${msg.date || msg.Date || ''}:${msg.subject || msg.Subject || ''}`\n  );\n  if (!key || key === '::' || seen.has(key)) continue;\n  seen.add(key);\n\n  const meta = readMeta(msg);\n  deduped.push({\n    json: {\n      ...msg,\n      ...meta,\n      backfill_contact_mode: normalizeMode(msg.backfill_contact_mode ?? msg.backfillMode ?? msg.metadata?.backfill_contact_mode),\n    },\n  });\n}\n\nreturn deduped;"
      },
      "id": "dedupe_messages",
      "name": "Dedupe Messages",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1260,
        260
      ]
    },
    {
      "parameters": {
        "jsCode": "const parseAddressList = (value) => {\n  if (!value) return [];\n  return String(value)\n    .split(',')\n    .map((chunk) => chunk.trim())\n    .filter(Boolean)\n    .map((entry) => {\n      const match = entry.match(/^(.*)<([^>]+)>$/);\n      if (match) {\n        const name = match[1].trim().replace(/(^\"|\"$)/g, '') || undefined;\n        return { email: match[2].trim().toLowerCase(), ...(name ? { name } : {}) };\n      }\n      return { email: entry.replace(/(^\"|\"$)/g, '').trim().toLowerCase() };\n    })\n    .filter((participant) => participant.email);\n};\n\nconst readHeader = (email, headerName) => {\n  const direct = email[headerName.toLowerCase()] ?? email[headerName];\n  if (direct) return direct;\n  const headers = email.payload?.headers ?? email.headers;\n  if (!Array.isArray(headers)) return '';\n  const found = headers.find((header) => String(header?.name ?? header?.key ?? '').toLowerCase() === headerName.toLowerCase());\n  return found?.value ?? '';\n};\n\nconst normalizeLabel = (label) => {\n  if (typeof label === 'string') return label.toUpperCase();\n  if (label && typeof label === 'object') return String(label.id || label.name || '').toUpperCase();\n  return '';\n};\n\nconst normalizeMode = (value) => {\n  const raw = String(value ?? '').trim().toLowerCase();\n  return raw === 'reprocess_all' ? 'reprocess_all' : 'skip_previously_processed';\n};\n\nreturn items.map((item, idx) => {\n  const email = item.json ?? {};\n  const labelsRaw = Array.isArray(email.labelIds) ? email.labelIds : Array.isArray(email.labels) ? email.labels : [];\n  const labels = labelsRaw.map(normalizeLabel).filter(Boolean);\n  const isSent = labels.includes('SENT');\n\n  const internalDate = email.internalDate ?? email.date ?? email.Date;\n  let timestamp = new Date().toISOString();\n  if (internalDate) {\n    const asNumber = Number(internalDate);\n    const parsedDate = Number.isFinite(asNumber) && asNumber > 0 ? new Date(asNumber) : new Date(internalDate);\n    if (!Number.isNaN(parsedDate.getTime())) timestamp = parsedDate.toISOString();\n  }\n\n  const fromHeader = readHeader(email, 'From') || email.from || '';\n  const toHeader = readHeader(email, 'To') || email.to || '';\n  const ccHeader = readHeader(email, 'Cc') || email.cc || '';\n  const bodyPlain = email.textPlain || email.bodyPlain || email.snippet || email.text || '';\n  const backfillMode = normalizeMode(email.backfill_contact_mode ?? email.backfillMode ?? email.metadata?.backfill_contact_mode);\n\n  return {\n    json: {\n      source_system: 'gmail',\n      event_type: isSent ? 'email_sent' : 'email_received',\n      external_id: String(email.id || email.messageId || readHeader(email, 'Message-ID') || `gmail-backfill-${Date.now()}-${idx}`),\n      timestamp,\n      thread_id: email.threadId ? String(email.threadId) : null,\n      direction: isSent ? 'out' : 'in',\n      subject: readHeader(email, 'Subject') || email.subject || '(no subject)',\n      participants: {\n        from: parseAddressList(fromHeader),\n        to: parseAddressList(toHeader),\n        cc: parseAddressList(ccHeader),\n      },\n      body_plain: String(bodyPlain),\n      attachments: Array.isArray(email.attachments) ? email.attachments : [],\n      contact_id: email.contact_id ?? email.metadata?.contact_id ?? null,\n      primary_email: email.primary_email ?? email.metadata?.primary_email ?? null,\n      window_after: email.window_after ?? email.metadata?.window_after ?? null,\n      window_before: email.window_before ?? email.metadata?.window_before ?? null,\n      backfill_contact_mode: backfillMode,\n    },\n  };\n});"
      },
      "id": "map_interaction",
      "name": "Map Interaction Event",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1520,
        260
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://api:8000/v1/ingest/interaction_event",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-Webhook-Secret",
              "value": "={{$env.N8N_WEBHOOK_SECRET}}"
            },
            {
              "name": "X-Reprocess-Duplicates",
              "value": "={{String($json.backfill_contact_mode || '').trim().toLowerCase() === 'reprocess_all' ? 'true' : 'false'}}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{$json}}",
        "options": {}
      },
      "id": "post_ingest",
      "name": "POST Interaction",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1780,
        260
      ],
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 5000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "return items.filter((item) => !item.json?.error);"
      },
      "id": "success_only",
      "name": "Success Only",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2040,
        180
      ]
    },
    {
      "parameters": {
        "jsCode": "return items.filter((item) => Boolean(item.json?.error)).map((item) => ({ json: { workflow: 'gmail_contact_backfill', failed_at: new Date().toISOString(), endpoint: 'http://api:8000/v1/ingest/interaction_event', error: item.json.error, response_payload: item.json } }));"
      },
      "id": "dead_letter_payload",
      "name": "Dead Letter Payload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2040,
        340
      ]
    }
  ],
  "connections": {
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Read Contacts Sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Contacts Sheet": {
      "main": [
        [
          {
            "node": "Build Contact Queue",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Contact Queue": {
      "main": [
        [
          {
            "node": "Gmail Get Many",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gmail Get Many": {
      "main": [
        [
          {
            "node": "Dedupe Messages",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dedupe Messages": {
      "main": [
        [
          {
            "node": "Map Interaction Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Interaction Event": {
      "main": [
        [
          {
            "node": "POST Interaction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "POST Interaction": {
      "main": [
        [
          {
            "node": "Success Only",
            "type": "main",
            "index": 0
          },
          {
            "node": "Dead Letter Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}

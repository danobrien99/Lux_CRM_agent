{"name":"gmail_contact_backfill","nodes":[{"parameters":{},"id":"manual","name":"Manual Trigger","type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[220,260]},{"parameters":{"authentication":"oAuth2","resource":"sheet","operation":"read","sheetId":"1_126A0A6-yX6n5sQYmsH_Jbk900yzjDaUy4jyX_aWT0","range":"Contacts_Short!A:Z","dataStartRow":2,"keyRow":1,"options":{"continue":true,"valueRenderMode":"UNFORMATTED_VALUE"}},"id":"read_contacts_sheet","name":"Read Contacts Sheet","type":"n8n-nodes-base.googleSheets","typeVersion":2,"position":[500,260]},{"parameters":{"jsCode":"const YEARS_BACK = 2; // How many years of history to backfill\nconst WINDOW_SIZE_MONTHS = 12; // Query one window at a time\nconst MAX_CONTACTS_PER_RUN = 0; // 0 = all contacts from sheet\nconst BACKFILL_CONTACT_MODE = 'skip_previously_processed'; // 'skip_previously_processed' or 'reprocess_all'\nconst BACKFILL_API_BASE_URL = 'http://api:8000';\n\nconst normalizedMode = String(BACKFILL_CONTACT_MODE || '').trim().toLowerCase();\nconst contactMode = normalizedMode === 'reprocess_all' ? 'reprocess_all' : 'skip_previously_processed';\n\nconst readField = (source, keys) => {\n  for (const key of keys) {\n    const value = source[key];\n    if (value !== undefined && value !== null && String(value).trim() !== '') return value;\n  }\n  return '';\n};\n\nconst normalizeEmail = (value) => {\n  if (value === null || value === undefined) return '';\n  let text = String(value).trim();\n  if (!text) return '';\n  text = text.replace(/^mailto:/i, '');\n  text = text.replace(/^e:\\s*/i, '');\n  text = text.replace(/^e\\s*:\\s*/i, '');\n  text = text.replace(/[<>]/g, '');\n  const m = text.match(/[a-z0-9._%+\\-']+@[a-z0-9.\\-]+\\.[a-z]{2,}/i);\n  return m ? m[0].toLowerCase() : '';\n};\n\nconst inferEmail = (source) => {\n  const direct = readField(source, ['primary_email', 'primaryEmail', 'Primary Email', 'Email', 'email', 'Work Email']);\n  const normalizedDirect = normalizeEmail(direct);\n  if (normalizedDirect) return normalizedDirect;\n  for (const value of Object.values(source || {})) {\n    const email = normalizeEmail(value);\n    if (email) return email;\n  }\n  return '';\n};\n\nconst slug = (value) => String(value || '')\n  .trim()\n  .toLowerCase()\n  .replace(/[^a-z0-9]+/g, '-')\n  .replace(/^-+|-+$/g, '')\n  .slice(0, 80);\n\nconst toIsoDate = (value) => {\n  const year = value.getUTCFullYear();\n  const month = String(value.getUTCMonth() + 1).padStart(2, '0');\n  const day = String(value.getUTCDate()).padStart(2, '0');\n  return `${year}/${month}/${day}`;\n};\n\nconst responseText = (body) => {\n  if (body === null || body === undefined) return '';\n  if (typeof body === 'string') return body;\n  try { return JSON.stringify(body); } catch { return String(body); }\n};\n\nconst responseJson = (body) => {\n  if (body && typeof body === 'object') return body;\n  if (!body) return {};\n  try { return JSON.parse(String(body)); } catch { return {}; }\n};\n\nconst httpRequest = async (options) => this.helpers.httpRequest({\n  ...options,\n  returnFullResponse: true,\n  ignoreHttpStatusErrors: true,\n  timeout: 120000,\n});\n\nconst unique = new Map();\nfor (const item of items) {\n  const source = item.json ?? {};\n  const email = inferEmail(source);\n  if (!email || unique.has(email)) continue;\n\n  const contactIdRaw = String(readField(source, ['contact_id', 'contactId', 'Contact ID', 'ContactId', 'HubSpot ID', 'Hubspot ID', 'ID'])).trim();\n  const contactId = contactIdRaw || `sheet:${slug(email)}`;\n  const explicitDisplayName = String(readField(source, ['display_name', 'displayName', 'Name', 'Full Name'])).trim();\n  const firstName = String(readField(source, ['first_name', 'firstName', 'First Name'])).trim();\n  const lastName = String(readField(source, ['last_name', 'lastName', 'Last Name'])).trim();\n  const displayName = explicitDisplayName || [firstName, lastName].filter(Boolean).join(' ') || null;\n  const companyName = String(readField(source, ['company', 'Company', 'organization', 'Organization', 'org', 'Org'])).trim() || null;\n  unique.set(email, {\n    contact_id: contactId || null,\n    primary_email: email,\n    contact_display_name: displayName,\n    contact_company: companyName,\n  });\n}\n\nconst contacts = Array.from(unique.values());\nif (contacts.length === 0) {\n  const sampleKeys = items[0]?.json ? Object.keys(items[0].json) : [];\n  throw new Error(`No contact emails found in sheet. Sample keys: ${sampleKeys.join(', ')}`);\n}\n\nconst limitedContacts = MAX_CONTACTS_PER_RUN > 0 ? contacts.slice(0, MAX_CONTACTS_PER_RUN) : contacts;\n\nlet processedContactIds = new Set();\nlet processedPrimaryEmails = new Set();\nif (contactMode === 'skip_previously_processed') {\n  const apiBaseUrl = String(BACKFILL_API_BASE_URL || 'http://api:8000').replace(/\\/+$/, '');\n  const statusUrl = `${apiBaseUrl}/v1/admin/backfill_contact_status`;\n  const headers = {};\n  if (\"9PZ5_Iw7ttWT6GJG0XIlG4platWDswpnROejWnfhGa7YwSXduGn7SBgwH2me3NlT\") headers['X-Webhook-Secret'] = \"9PZ5_Iw7ttWT6GJG0XIlG4platWDswpnROejWnfhGa7YwSXduGn7SBgwH2me3NlT\";\n\n  const response = await httpRequest({ method: 'GET', url: statusUrl, headers, json: false });\n  const statusCode = Number(response?.statusCode ?? response?.status ?? 0);\n  const bodyText = responseText(response?.body);\n  if (statusCode < 200 || statusCode >= 300) {\n    throw new Error(`Failed fetching processed contacts (${statusCode || 'unknown'}): ${bodyText.slice(0, 240)}`);\n  }\n\n  const payload = responseJson(response?.body);\n  const ids = Array.isArray(payload?.processed_contact_ids) ? payload.processed_contact_ids : [];\n  const emails = Array.isArray(payload?.processed_primary_emails) ? payload.processed_primary_emails : [];\n  processedContactIds = new Set(ids.map((v) => String(v).trim()).filter(Boolean));\n  processedPrimaryEmails = new Set(emails.map((v) => String(v).trim().toLowerCase()).filter(Boolean));\n}\n\nconst selectedContacts = limitedContacts.filter((contact) => {\n  if (contactMode !== 'skip_previously_processed') return true;\n  const cid = String(contact.contact_id || '').trim();\n  if (cid && processedContactIds.has(cid)) return false;\n  return !processedPrimaryEmails.has(contact.primary_email);\n});\n\nif (selectedContacts.length === 0) return [];\n\nconst now = new Date();\nconst backfillStart = new Date(Date.UTC(now.getUTCFullYear() - YEARS_BACK, now.getUTCMonth(), now.getUTCDate()));\nconst queue = [];\n\nfor (let index = 0; index < selectedContacts.length; index += 1) {\n  const contact = selectedContacts[index];\n  let cursorEnd = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + 1));\n\n  while (cursorEnd > backfillStart) {\n    let cursorStart = new Date(cursorEnd);\n    cursorStart.setUTCMonth(cursorStart.getUTCMonth() - WINDOW_SIZE_MONTHS);\n    if (cursorStart < backfillStart) cursorStart = new Date(backfillStart);\n\n    const after = toIsoDate(cursorStart);\n    const before = toIsoDate(cursorEnd);\n    const query = `(from:${contact.primary_email} OR to:${contact.primary_email} OR cc:${contact.primary_email}) after:${after} before:${before}`;\n\n    queue.push({ json: {\n      ...contact,\n      query,\n      window_after: after,\n      window_before: before,\n      contact_index: index + 1,\n      contact_total: selectedContacts.length,\n      backfill_contact_mode: contactMode,\n    } });\n\n    cursorEnd = cursorStart;\n  }\n}\n\nif (queue.length === 0) {\n  throw new Error('Backfill queue is empty. Check YEARS_BACK and contact sheet values.');\n}\n\nreturn queue;"},"id":"build_contact_queue","name":"Build Contact Queue","type":"n8n-nodes-base.code","typeVersion":2,"position":[760,260]},{"parameters":{"authentication":"oAuth2","resource":"message","operation":"getAll","returnAll":true,"simple":true,"filters":{"q":"={{$json.query}}","readStatus":"both"},"options":{}},"id":"gmail_get_many","name":"Gmail Get Many","type":"n8n-nodes-base.gmail","typeVersion":2.2,"position":[1020,260],"continueOnFail":true},{"parameters":{"jsCode":"const normalizeMode = (value) => {\n  const raw = String(value ?? '').trim().toLowerCase();\n  return raw === 'reprocess_all' ? 'reprocess_all' : 'skip_previously_processed';\n};\n\nconst readMeta = (payload) => {\n  const source = payload && typeof payload === 'object' ? payload : {};\n  const metadata = source.metadata && typeof source.metadata === 'object' ? source.metadata : {};\n  return {\n    contact_id: source.contact_id ?? metadata.contact_id ?? null,\n    primary_email: source.primary_email ?? metadata.primary_email ?? null,\n    window_after: source.window_after ?? metadata.window_after ?? null,\n    window_before: source.window_before ?? metadata.window_before ?? null,\n    query: source.query ?? metadata.query ?? null,\n    contact_display_name: source.contact_display_name ?? metadata.contact_display_name ?? null,\n    contact_company: source.contact_company ?? metadata.contact_company ?? null,\n    backfill_contact_mode: source.backfill_contact_mode ?? metadata.backfill_contact_mode ?? source.backfillMode ?? metadata.backfillMode ?? null,\n  };\n};\n\nconst emailRegex = /[a-z0-9._%+'-]+@[a-z0-9.-]+\\.[a-z]{2,}/ig;\nconst extractEmails = (payload) => {\n  const source = payload && typeof payload === 'object' ? payload : {};\n  const candidates = [source.primary_email, source.email, source.From, source.To, source.Cc, source.from, source.to, source.cc];\n  const found = new Set();\n  for (const value of candidates) {\n    if (value === undefined || value === null) continue;\n    const text = String(value);\n    for (const match of text.matchAll(emailRegex)) {\n      found.add(String(match[0]).toLowerCase());\n    }\n  }\n  return Array.from(found);\n};\n\nconst gmailOutputItems = (() => {\n  try {\n    const rows = $items('Gmail Get Many');\n    return Array.isArray(rows) ? rows : [];\n  } catch {\n    return [];\n  }\n})();\n\nconst queueByEmail = new Map();\ntry {\n  const queueItems = $items('Build Contact Queue');\n  if (Array.isArray(queueItems)) {\n    for (const entry of queueItems) {\n      const meta = readMeta(entry?.json);\n      const email = String(meta.primary_email ?? '').trim().toLowerCase();\n      if (!email || queueByEmail.has(email)) continue;\n      queueByEmail.set(email, meta);\n    }\n  }\n} catch {}\n\nconst seen = new Set();\nconst deduped = [];\nconst getPairedQueueMeta = (item) => {\n  const paired = item?.pairedItem;\n  const pairedIndex = typeof paired?.item === 'number' ? paired.item : (Array.isArray(paired) && typeof paired[0]?.item === 'number' ? paired[0].item : null);\n  if (pairedIndex === null) return {};\n\n  let queueIndex = pairedIndex;\n  try {\n    const gmailUpstream = $items('Gmail Get Many', 0, pairedIndex);\n    const gmailItem = Array.isArray(gmailUpstream) ? gmailUpstream[0] : null;\n    const gmailPaired = gmailItem?.pairedItem;\n    const gmailPairIndex = typeof gmailPaired?.item === 'number'\n      ? gmailPaired.item\n      : (Array.isArray(gmailPaired) && typeof gmailPaired[0]?.item === 'number' ? gmailPaired[0].item : null);\n    if (gmailPairIndex !== null) queueIndex = gmailPairIndex;\n  } catch {}\n  try {\n    const gmailItem = gmailOutputItems[pairedIndex] ?? null;\n    const gmailPaired = gmailItem?.pairedItem;\n    const gmailPairIndex = typeof gmailPaired?.item === 'number'\n      ? gmailPaired.item\n      : (Array.isArray(gmailPaired) && typeof gmailPaired[0]?.item === 'number' ? gmailPaired[0].item : null);\n    if (gmailPairIndex !== null) queueIndex = gmailPairIndex;\n  } catch {}\n\n  try {\n    const upstream = $items('Build Contact Queue', 0, queueIndex);\n    if (Array.isArray(upstream) && upstream[0]?.json) return upstream[0].json;\n  } catch {}\n  try {\n    const upstreamAll = $items('Build Contact Queue');\n    if (Array.isArray(upstreamAll) && upstreamAll[queueIndex]?.json) return upstreamAll[queueIndex].json;\n  } catch {}\n  return {};\n};\nconst inferQueueMetaFromMessage = (msg) => {\n  for (const email of extractEmails(msg)) {\n    const meta = queueByEmail.get(email);\n    if (meta) return meta;\n  }\n  return {};\n};\n\nfor (const item of items) {\n  const msg = item.json ?? {};\n  const key = String(msg.id || msg.messageId || msg['Message-ID'] || `${msg.threadId || ''}:${msg.date || msg.Date || ''}:${msg.subject || msg.Subject || ''}`);\n  if (!key || key === '::' || seen.has(key)) continue;\n  seen.add(key);\n  const inferredMeta = readMeta(inferQueueMetaFromMessage(msg));\n  const pairedMeta = readMeta(getPairedQueueMeta(item));\n  const msgMeta = readMeta(msg);\n  const meta = { ...inferredMeta, ...pairedMeta, ...msgMeta };\n  deduped.push({\n    json: {\n      ...msg,\n      ...meta,\n      backfill_contact_mode: normalizeMode(msg.backfill_contact_mode ?? msg.backfillMode ?? msg.metadata?.backfill_contact_mode ?? meta.backfill_contact_mode),\n    },\n  });\n}\n\nreturn deduped;"},"id":"dedupe_messages","name":"Dedupe Messages","type":"n8n-nodes-base.code","typeVersion":2,"position":[1260,260]},{"parameters":{"jsCode":"const parseAddressList = (value) => {\n  if (!value) return [];\n  return String(value)\n    .split(',')\n    .map((chunk) => chunk.trim())\n    .filter(Boolean)\n    .map((entry) => {\n      const match = entry.match(/^(.*)<([^>]+)>$/);\n      if (match) {\n        const name = match[1].trim().replace(/(^\"|\"$)/g, '') || undefined;\n        return { email: match[2].trim().toLowerCase(), ...(name ? { name } : {}) };\n      }\n      return { email: entry.replace(/(^\"|\"$)/g, '').trim().toLowerCase() };\n    })\n    .filter((participant) => participant.email);\n};\n\nconst readHeader = (email, headerName) => {\n  const direct = email[headerName.toLowerCase()] ?? email[headerName];\n  if (direct) return direct;\n  const headers = email.payload?.headers ?? email.headers;\n  if (!Array.isArray(headers)) return '';\n  const found = headers.find((header) => String(header?.name ?? header?.key ?? '').toLowerCase() === headerName.toLowerCase());\n  return found?.value ?? '';\n};\n\nconst normalizeLabel = (label) => {\n  if (typeof label === 'string') return label.toUpperCase();\n  if (label && typeof label === 'object') return String(label.id || label.name || '').toUpperCase();\n  return '';\n};\n\nconst normalizeMode = (value) => {\n  const raw = String(value ?? '').trim().toLowerCase();\n  return raw === 'reprocess_all' ? 'reprocess_all' : 'skip_previously_processed';\n};\n\nreturn items.map((item, idx) => {\n  const email = item.json ?? {};\n  const labelsRaw = Array.isArray(email.labelIds) ? email.labelIds : Array.isArray(email.labels) ? email.labels : [];\n  const labels = labelsRaw.map(normalizeLabel).filter(Boolean);\n  const isSent = labels.includes('SENT');\n\n  const internalDate = email.internalDate ?? email.date ?? email.Date;\n  let timestamp = new Date().toISOString();\n  if (internalDate) {\n    const asNumber = Number(internalDate);\n    const parsedDate = Number.isFinite(asNumber) && asNumber > 0 ? new Date(asNumber) : new Date(internalDate);\n    if (!Number.isNaN(parsedDate.getTime())) timestamp = parsedDate.toISOString();\n  }\n\n  const fromHeader = readHeader(email, 'From') || email.from || '';\n  const toHeader = readHeader(email, 'To') || email.to || '';\n  const ccHeader = readHeader(email, 'Cc') || email.cc || '';\n  const bodyPlain = email.textPlain || email.bodyPlain || email.snippet || email.text || '';\n  const backfillMode = normalizeMode(email.backfill_contact_mode ?? email.backfillMode ?? email.metadata?.backfill_contact_mode);\n\n  return {\n    json: {\n      source_system: 'gmail',\n      event_type: isSent ? 'email_sent' : 'email_received',\n      external_id: String(email.id || email.messageId || readHeader(email, 'Message-ID') || `gmail-backfill-${Date.now()}-${idx}`),\n      timestamp,\n      thread_id: email.threadId ? String(email.threadId) : null,\n      direction: isSent ? 'out' : 'in',\n      subject: readHeader(email, 'Subject') || email.subject || '(no subject)',\n      participants: {\n        from: parseAddressList(fromHeader),\n        to: parseAddressList(toHeader),\n        cc: parseAddressList(ccHeader),\n      },\n      body_plain: String(bodyPlain),\n      attachments: Array.isArray(email.attachments) ? email.attachments : [],\n      contact_id: email.contact_id ?? email.metadata?.contact_id ?? null,\n      primary_email: email.primary_email ?? email.metadata?.primary_email ?? null,\n      contact_display_name: email.contact_display_name ?? email.metadata?.contact_display_name ?? null,\n      contact_company: email.contact_company ?? email.metadata?.contact_company ?? null,\n      window_after: email.window_after ?? email.metadata?.window_after ?? null,\n      window_before: email.window_before ?? email.metadata?.window_before ?? null,\n      backfill_contact_mode: backfillMode,\n    },\n  };\n});"},"id":"map_interaction","name":"Map Interaction Event","type":"n8n-nodes-base.code","typeVersion":2,"position":[1520,260]},{"parameters":{"jsCode":"const endpoint = 'http://api:8000/v1/ingest/interaction_event';\nconst batchSize = Math.max(1, 20);\nconst pauseMs = Math.max(0, 250);\nconst timeoutMs = Math.max(1000, 120000);\n\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nconst responseText = (body) => {\n  if (body === null || body === undefined) return '';\n  if (typeof body === 'string') return body;\n  try { return JSON.stringify(body); } catch { return String(body); }\n};\nconst responseJson = (body) => {\n  if (body && typeof body === 'object') return body;\n  if (!body) return {};\n  try { return JSON.parse(String(body)); } catch { return { raw: responseText(body) }; }\n};\nconst httpRequest = async (options, timeout) => this.helpers.httpRequest({\n  ...options,\n  returnFullResponse: true,\n  ignoreHttpStatusErrors: true,\n  timeout,\n});\n\nconst lookupEndpointBase = 'http://api:8000/v1/contacts/lookup';\nconst contactLookupCache = new Map();\nconst participantEmails = (payload) => {\n  const out = [];\n  const seen = new Set();\n  const push = (value) => {\n    const email = String(value ?? '').trim().toLowerCase();\n    if (!email || seen.has(email)) return;\n    seen.add(email);\n    out.push(email);\n  };\n  const participants = payload?.participants && typeof payload.participants === 'object' ? payload.participants : {};\n  const direction = String(payload?.direction ?? '').toLowerCase();\n  const buckets = direction === 'out' ? ['to', 'cc', 'from'] : ['from', 'to', 'cc'];\n  for (const bucket of buckets) {\n    const rows = Array.isArray(participants[bucket]) ? participants[bucket] : [];\n    for (const row of rows) {\n      push(row?.email);\n    }\n  }\n  push(payload?.primary_email);\n  return out;\n};\nconst lookupContact = async (email, headers) => {\n  if (!email) return null;\n  if (contactLookupCache.has(email)) return contactLookupCache.get(email);\n  try {\n    const response = await httpRequest({\n      url: `${lookupEndpointBase}?email=${encodeURIComponent(email)}`,\n      method: 'GET',\n      headers,\n      json: false,\n    }, Math.min(timeoutMs, 10000));\n    const statusCode = Number(response?.statusCode ?? response?.status ?? 0);\n    const body = responseJson(response?.body);\n    const result = statusCode >= 200 && statusCode < 300 && body?.contact_id ? body : null;\n    contactLookupCache.set(email, result);\n    return result;\n  } catch {\n    contactLookupCache.set(email, null);\n    return null;\n  }\n};\n\nconst results = [];\nfor (let start = 0; start < items.length; start += batchSize) {\n  const batch = items.slice(start, start + batchSize);\n  for (const item of batch) {\n    const payload = item.json ?? {};\n    const hydratedPayload = { ...payload };\n    const requestedMode = String(payload.backfill_contact_mode || '').trim().toLowerCase();\n    const mode = requestedMode === 'reprocess_all'\n      ? 'reprocess_all'\n      : 'skip_previously_processed';\n    hydratedPayload.backfill_contact_mode = mode;\n\n    const headers = { 'Content-Type': 'application/json' };\n    if (\"9PZ5_Iw7ttWT6GJG0XIlG4platWDswpnROejWnfhGa7YwSXduGn7SBgwH2me3NlT\") {\n      headers['X-Webhook-Secret'] = \"9PZ5_Iw7ttWT6GJG0XIlG4platWDswpnROejWnfhGa7YwSXduGn7SBgwH2me3NlT\";\n    }\n    headers['X-Reprocess-Duplicates'] = mode === 'reprocess_all' ? 'true' : 'false';\n\n    const missingHints = !hydratedPayload.contact_id || !hydratedPayload.primary_email;\n    if (missingHints) {\n      let provisionalHit = null;\n      for (const email of participantEmails(hydratedPayload)) {\n        const hit = await lookupContact(email, headers);\n        if (!hit) continue;\n        const hitId = String(hit.contact_id || '');\n        const isProvisional = hitId.startsWith('contact:provisional:');\n        if (!isProvisional) {\n          hydratedPayload.contact_id = hydratedPayload.contact_id || hit.contact_id || null;\n          hydratedPayload.primary_email = hydratedPayload.primary_email || hit.primary_email || email;\n          hydratedPayload.contact_display_name = hydratedPayload.contact_display_name || hit.display_name || null;\n          provisionalHit = null;\n          break;\n        }\n        if (!provisionalHit) provisionalHit = { hit, email };\n      }\n      if ((!hydratedPayload.contact_id || !hydratedPayload.primary_email) && provisionalHit) {\n        const { hit, email } = provisionalHit;\n        hydratedPayload.contact_id = hydratedPayload.contact_id || hit.contact_id || null;\n        hydratedPayload.primary_email = hydratedPayload.primary_email || hit.primary_email || email;\n        hydratedPayload.contact_display_name = hydratedPayload.contact_display_name || hit.display_name || null;\n      }\n    }\n\n    try {\n      const response = await httpRequest({\n        url: endpoint,\n        method: 'POST',\n        headers,\n        json: false,\n        body: JSON.stringify(hydratedPayload),\n      }, timeoutMs);\n\n      const statusCode = Number(response?.statusCode ?? response?.status ?? 0);\n      const parsedBody = responseJson(response?.body);\n\n      if (statusCode < 200 || statusCode >= 300) {\n        results.push({\n          json: {\n            error: {\n              message: `HTTP ${statusCode || 'unknown'} from ingest endpoint`,\n              status: statusCode || null,\n              body: parsedBody,\n            },\n            endpoint,\n            meta: {\n              external_id: hydratedPayload.external_id ?? null,\n              contact_id: hydratedPayload.contact_id ?? null,\n              primary_email: hydratedPayload.primary_email ?? null,\n              backfill_contact_mode: mode,\n            },\n          },\n        });\n        continue;\n      }\n\n      results.push({\n        json: {\n          ...parsedBody,\n          endpoint,\n          statusCode: statusCode || null,\n          meta: {\n            external_id: hydratedPayload.external_id ?? null,\n            contact_id: hydratedPayload.contact_id ?? null,\n            primary_email: hydratedPayload.primary_email ?? null,\n            backfill_contact_mode: mode,\n          },\n        },\n      });\n    } catch (error) {\n      results.push({\n        json: {\n          error: {\n            message: error?.message || String(error),\n            name: error?.name || 'Error',\n          },\n          endpoint,\n          meta: {\n            external_id: hydratedPayload.external_id ?? null,\n            contact_id: hydratedPayload.contact_id ?? null,\n            primary_email: hydratedPayload.primary_email ?? null,\n            backfill_contact_mode: mode,\n          },\n        },\n      });\n    }\n  }\n\n  if (start + batchSize < items.length && pauseMs > 0) {\n    await sleep(pauseMs);\n  }\n}\n\nreturn results;"},"id":"post_ingest","name":"POST Interaction","type":"n8n-nodes-base.code","typeVersion":2,"position":[1780,260],"continueOnFail":true},{"parameters":{"jsCode":"return items.filter((item) => !item.json?.error);"},"id":"success_only","name":"Success Only","type":"n8n-nodes-base.code","typeVersion":2,"position":[2040,180]},{"parameters":{"jsCode":"return items.filter((item) => Boolean(item.json?.error)).map((item) => ({ json: { workflow: 'gmail_contact_backfill', failed_at: new Date().toISOString(), endpoint: 'http://api:8000/v1/ingest/interaction_event', error: item.json.error, response_payload: item.json } }));"},"id":"dead_letter_payload","name":"Dead Letter Payload","type":"n8n-nodes-base.code","typeVersion":2,"position":[2040,340]},{"parameters":{"jsCode":"const endpoint = 'http://api:8000/v1/admin/backfill_runs/report';\nconst nowIso = new Date().toISOString();\nconst runId = `gmail-contact-backfill-${Date.now()}`;\nconst total = items.length;\nconst dead = items.filter((item) => Boolean(item.json?.error));\nconst success = total - dead.length;\n\nconst modeSource = items.find((item) => item.json?.meta?.backfill_contact_mode)?.json?.meta?.backfill_contact_mode;\nconst mode = String(modeSource || 'unknown');\n\nconst errorSamples = dead.slice(0, 20).map((item) => ({\n  message: item.json?.error?.message || 'unknown',\n  name: item.json?.error?.name || null,\n  status: item.json?.error?.status || null,\n  external_id: item.json?.meta?.external_id || null,\n  contact_id: item.json?.meta?.contact_id || null,\n  primary_email: item.json?.meta?.primary_email || null,\n}));\n\nconst payload = {\n  workflow: 'gmail_contact_backfill',\n  run_id: runId,\n  status: dead.length > 0 ? 'warning' : 'success',\n  mode,\n  total_items: total,\n  success_items: success,\n  dead_letter_items: dead.length,\n  dead_letter_ratio: total > 0 ? dead.length / total : 0,\n  generated_at: nowIso,\n  error_samples: errorSamples,\n  notes: dead.length > 0\n    ? `Backfill completed with ${dead.length} dead-letter items.`\n    : 'Backfill completed with no dead-letter items.',\n};\n\nconst responseText = (body) => {\n  if (body === null || body === undefined) return '';\n  if (typeof body === 'string') return body;\n  try { return JSON.stringify(body); } catch { return String(body); }\n};\nconst responseJson = (body) => {\n  if (body && typeof body === 'object') return body;\n  if (!body) return {};\n  try { return JSON.parse(String(body)); } catch { return { raw: responseText(body) }; }\n};\n\nconst headers = { 'Content-Type': 'application/json' };\nif (\"9PZ5_Iw7ttWT6GJG0XIlG4platWDswpnROejWnfhGa7YwSXduGn7SBgwH2me3NlT\") {\n  headers['X-Webhook-Secret'] = \"9PZ5_Iw7ttWT6GJG0XIlG4platWDswpnROejWnfhGa7YwSXduGn7SBgwH2me3NlT\";\n}\n\nlet persisted = false;\nlet persistResponse = {};\ntry {\n  const response = await this.helpers.httpRequest({\n    url: endpoint,\n    method: 'POST',\n    headers,\n    json: false,\n    body: JSON.stringify(payload),\n    returnFullResponse: true,\n    ignoreHttpStatusErrors: true,\n    timeout: 120000,\n  });\n\n  const statusCode = Number(response?.statusCode ?? response?.status ?? 0);\n  const body = responseJson(response?.body);\n\n  persisted = statusCode >= 200 && statusCode < 300;\n  persistResponse = { status: statusCode || null, body };\n  if (!persisted) {\n    payload.status = payload.status === 'success' ? 'warning' : payload.status;\n    payload.notes = `${payload.notes} Persist call failed with HTTP ${statusCode || 'unknown'}.`;\n  }\n} catch (error) {\n  payload.status = payload.status === 'success' ? 'warning' : payload.status;\n  payload.notes = `${payload.notes} Persist call failed: ${error?.message || String(error)}.`;\n  persistResponse = { error: error?.message || String(error) };\n}\n\nreturn [{ json: { ...payload, persisted, persist_response: persistResponse } }];"},"id":"persist_backfill_summary","name":"Persist Backfill Summary","type":"n8n-nodes-base.code","typeVersion":2,"position":[2040,500]}],"connections":{"Manual Trigger":{"main":[[{"node":"Read Contacts Sheet","type":"main","index":0}]]},"Read Contacts Sheet":{"main":[[{"node":"Build Contact Queue","type":"main","index":0}]]},"Build Contact Queue":{"main":[[{"node":"Gmail Get Many","type":"main","index":0}]]},"Gmail Get Many":{"main":[[{"node":"Dedupe Messages","type":"main","index":0}]]},"Dedupe Messages":{"main":[[{"node":"Map Interaction Event","type":"main","index":0}]]},"Map Interaction Event":{"main":[[{"node":"POST Interaction","type":"main","index":0}]]},"POST Interaction":{"main":[[{"node":"Success Only","type":"main","index":0},{"node":"Dead Letter Payload","type":"main","index":0},{"node":"Persist Backfill Summary","type":"main","index":0}]]}},"settings":{"executionOrder":"v1"}}